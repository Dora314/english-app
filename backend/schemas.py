# backend/schemas.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict # Dict for selected_answers

class MCQOption(BaseModel):
    id: str # e.g., "A", "B", "C", "D" or unique int
    text: str

class QuestionBase(BaseModel):
    id: str # Unique ID for the question
    question_text: str
    options: List[MCQOption]
    # We'll omit correct_answer_text from what's sent to frontend initially
    # to prevent users from seeing it in network requests before submission.
    # The backend will know the correct answer.

class QuestionResponse(QuestionBase):
    pass # For now, same as base

class GenerateMCQsRequest(BaseModel):
    topic_string: str
    num_questions: int = 5 # Default to 5 questions if not specified

class GenerateMCQsResponse(BaseModel):
    questions: List[QuestionResponse]
    topic_id: Optional[str] = None # Placeholder for when we save topics

class SubmitAnswerRequest(BaseModel):
    question_id: str
    selected_answer_id: str # The ID of the option selected (e.g., "A", "B")
    # selected_answer_text: str # Alternatively, you could send the text
    # quiz_session_id: Optional[str] = None # If grouping answers by a quiz session

class SubmitAnswerResponse(BaseModel):
    is_correct: bool
    correct_answer_id: Optional[str] = None # Send back the ID of the correct option
    correct_answer_text: Optional[str] = None # Or the text
    current_points: Optional[int] = None # User's updated total points
    # explanation: Optional[str] = None # Optional: explanation for the answer

class SubmitQuizSessionRequest(BaseModel):
    # The frontend will send the map of answers: { questionId: selectedOptionId }
    # This allows the backend to calculate points for this session.
    answers_map: Dict[str, str] = Field(..., description="Map of question IDs to selected option IDs for the session")
    topic_id: Optional[str] = None # The topic_id returned by  endpoint
    # quiz_session_id: Optional[str] = None # Could be generated by frontend or backend

# New Schemas for Dashboard Data
class WrongdoingQuestionInfo(BaseModel):
    question_id: str
    question_text: str
    timestamp_marked_wrong: str # Or datetime, FastAPI will serialize
    # Optionally:
    # selected_incorrect_answer: Optional[str] = None
    # correct_answer: Optional[str] = None

class DashboardDataResponse(BaseModel):
    user_id: str
    total_points: int
    previous_session_points: int
    points_history: List[Dict] # Parsed from JSON string in DB
    last_5_wrong_questions: List[WrongdoingQuestionInfo]

class SubmitQuizSessionResponse(BaseModel):
    message: str
    session_points_earned: int
    updated_dashboard_data: DashboardDataResponse # Changed to use the new DashboardDataResponse